<!DOCTYPE html>

<html>
<head>
<meta charset="utf-8">

<title>class MeterAggregation - Rails Application Documentation</title>

<script type="text/javascript">
  var rdoc_rel_prefix = "./";
</script>

<script src="./js/jquery.js"></script>
<script src="./js/darkfish.js"></script>

<link href="./css/fonts.css" rel="stylesheet">
<link href="./css/rdoc.css" rel="stylesheet">



<body id="top" role="document" class="class">
<nav role="navigation">
  <div id="project-navigation">
    <div id="home-section" role="region" title="Quick navigation" class="nav-section">
  <h2>
    <a href="./index.html" rel="home">Home</a>
  </h2>

  <div id="table-of-contents-navigation">
    <a href="./table_of_contents.html#pages">Pages</a>
    <a href="./table_of_contents.html#classes">Classes</a>
    <a href="./table_of_contents.html#methods">Methods</a>
  </div>
</div>

    <div id="search-section" role="search" class="project-section initially-hidden">
  <form action="#" method="get" accept-charset="utf-8">
    <div id="search-field-wrapper">
      <input id="search-field" role="combobox" aria-label="Search"
             aria-autocomplete="list" aria-controls="search-results"
             type="text" name="search" placeholder="Search" spellcheck="false"
             title="Type to search, Up and Down to navigate, Enter to load">
    </div>

    <ul id="search-results" aria-label="Search Results"
        aria-busy="false" aria-expanded="false"
        aria-atomic="false" class="initially-hidden"></ul>
  </form>
</div>

  </div>

  

  <div id="class-metadata">
    
    <div id="parent-class-section" class="nav-section">
  <h3>Parent</h3>

  
  <p class="link">ActiveRecord::Base
  
</div>

    <div id="includes-section" class="nav-section">
  <h3>Included Modules</h3>

  <ul class="link-list">
  
  
    <li><a class="include" href="Metering.html">Metering</a>
  
  
  </ul>
</div>

    
    <!-- Method Quickref -->
<div id="method-list-section" class="nav-section">
  <h3>Methods</h3>

  <ul class="link-list" role="directory">
    
    <li ><a href="#method-c-aggregate_and_store">::aggregate_and_store</a>
    
    <li ><a href="#method-c-aggregate_missing_data">::aggregate_missing_data</a>
    
    <li ><a href="#method-c-confidence_query">::confidence_query</a>
    
    <li ><a href="#method-c-daily_full_usage_sums">::daily_full_usage_sums</a>
    
    <li ><a href="#method-c-daily_usage_hash">::daily_usage_hash</a>
    
    <li ><a href="#method-c-daily_usage_sums">::daily_usage_sums</a>
    
    <li ><a href="#method-c-dtp_meter_usage">::dtp_meter_usage</a>
    
    <li ><a href="#method-c-dtp_meter_usage_sums">::dtp_meter_usage_sums</a>
    
    <li ><a href="#method-c-dtp_usage">::dtp_usage</a>
    
    <li ><a href="#method-c-inclusive_usage">::inclusive_usage</a>
    
    <li ><a href="#method-c-meter_usage">::meter_usage</a>
    
    <li ><a href="#method-c-total_dtp_usage_sums">::total_dtp_usage_sums</a>
    
    <li ><a href="#method-c-total_meter_usage_sums">::total_meter_usage_sums</a>
    
    <li ><a href="#method-c-total_usage_sums">::total_usage_sums</a>
    
    <li ><a href="#method-c-usage_by_dtp">::usage_by_dtp</a>
    
    <li ><a href="#method-c-usage_by_meter">::usage_by_meter</a>
    
  </ul>
</div>

  </div>
</nav>

<main role="main" aria-labelledby="class-MeterAggregation">
  <h1 id="class-MeterAggregation" class="class">
    class MeterAggregation
  </h1>

  <section class="description">
    
  </section>

  
  
  
  <section id="5Buntitled-5D" class="documentation-section">
    

    

    

    

    
     <section id="public-class-5Buntitled-5D-method-details" class="method-section">
       <header>
         <h3>Public Class Methods</h3>
       </header>

    
      <div id="method-c-aggregate_and_store" class="method-detail ">
        
        <div class="method-heading">
          <span class="method-name">aggregate_and_store</span><span
            class="method-args">(date_ranges, daily_time_periods, meters)</span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        

        <div class="method-description">
          
          <p>Aggregates usage for Daily Time Periods from existing MeterRecords.</p>

<p>Author: Reuben Braithwaite</p>

<h4 id="method-c-aggregate_and_store-label-Inputs">Inputs<span><a href="#method-c-aggregate_and_store-label-Inputs">&para;</a> <a href="#top">&uarr;</a></span></h4>
<ul><li>
<p><code>date_ranges</code> - an array of hashes, each containing a Date
<code>start_date</code> and Date <code>end_date</code> as specified in <a
href="Meter.html">Meter</a> interface of SDD</p>
</li><li>
<p><code>daily_time_periods</code> - an array of hashes, each containing a
Time <code>start_time</code>, Time <code>end_time</code> and, optionally, a
String <code>label</code>, as specified in <a href="Meter.html">Meter</a>
interface of SDD</p>
</li><li>
<p><code>meters</code> - an array of <a href="Meter.html">Meter</a> objects</p>
</li></ul>

<h3 id="method-c-aggregate_and_store-label-Outputs">Outputs<span><a href="#method-c-aggregate_and_store-label-Outputs">&para;</a> <a href="#top">&uarr;</a></span></h3>

<p>None</p>
          
          

          
          <div class="method-source-code" id="aggregate_and_store-source">
            <pre><span class="ruby-comment"># File app/models/meter_aggregation.rb, line 619</span>
  <span class="ruby-keyword">def</span> <span class="ruby-keyword">self</span>.<span class="ruby-identifier">aggregate_and_store</span> <span class="ruby-identifier">date_ranges</span>, <span class="ruby-identifier">daily_time_periods</span>, <span class="ruby-identifier">meters</span>

    <span class="ruby-comment">################################################################################</span>
    <span class="ruby-comment"># Inserting MeterAggregations</span>
    <span class="ruby-comment">#</span>

<span class="ruby-comment">#   Add a time period to aggregate for the whole day</span>
    <span class="ruby-identifier">daily_time_periods</span>.<span class="ruby-identifier">push</span>(<span class="ruby-identifier">all_day</span>)

<span class="ruby-comment">#   Don&#39;t bother if there&#39;s nothing to aggregate</span>
    <span class="ruby-keyword">if</span> <span class="ruby-keyword">not</span> ( <span class="ruby-identifier">date_ranges</span>.<span class="ruby-identifier">empty?</span> <span class="ruby-keyword">or</span> <span class="ruby-identifier">daily_time_periods</span>.<span class="ruby-identifier">empty?</span> <span class="ruby-keyword">or</span> <span class="ruby-identifier">meters</span>.<span class="ruby-identifier">empty?</span> )

<span class="ruby-comment">#     This is a hash of Meters we&#39;ll be aggregating</span>
      <span class="ruby-identifier">whitelist</span> = <span class="ruby-constant">Meter</span>.<span class="ruby-identifier">whitelist</span> <span class="ruby-identifier">meters</span>

<span class="ruby-comment">#     Create a WHERE clause to select by date range</span>
<span class="ruby-comment">#     Multiple start/end dates are possible</span>
      <span class="ruby-identifier">date_ranges_where</span> = <span class="ruby-identifier">date_ranges</span>.<span class="ruby-identifier">map</span>{
        <span class="ruby-operator">|</span><span class="ruby-identifier">date_range</span><span class="ruby-operator">|</span>
        <span class="ruby-node">&quot;( date &gt;= &#39;#{date_range[:start_date]}&#39; AND date &lt;= &#39;#{date_range[:end_date]}&#39; )&quot;</span>
      }.<span class="ruby-identifier">join</span>(<span class="ruby-string">&quot; OR &quot;</span>)


<span class="ruby-comment">#     Create a CASE statement in order to convert the usage to k</span>
      <span class="ruby-identifier">uom_usage_cases</span> = <span class="ruby-identifier">nem12_uom</span>.<span class="ruby-identifier">map</span>{
        <span class="ruby-operator">|</span><span class="ruby-identifier">uom</span><span class="ruby-operator">|</span> <span class="ruby-node">&quot;              WHEN ( uom = LOWER(&#39;#{uom}&#39;) ) THEN usage * #{nem12_uom_to_kwh_multiplier uom}&quot;</span>
      }.<span class="ruby-identifier">join</span>(<span class="ruby-string">&quot;\n&quot;</span>)

<span class="ruby-comment">#     Create a CASE statement in order to convert the unit of measurement to k</span>
      <span class="ruby-identifier">uom_unit_cases</span> = <span class="ruby-identifier">nem12_uom</span>.<span class="ruby-identifier">map</span>{
        <span class="ruby-operator">|</span><span class="ruby-identifier">uom</span><span class="ruby-operator">|</span> <span class="ruby-node">&quot;              WHEN ( uom = LOWER(&#39;#{uom}&#39;) ) THEN &#39;#{nem12_uom_to_kuom uom}&#39;&quot;</span>
      }.<span class="ruby-identifier">join</span>(<span class="ruby-string">&quot;\n&quot;</span>)

<span class="ruby-comment">#     Initialise an array to</span>
      <span class="ruby-identifier">aggregations</span> = []

<span class="ruby-comment">#     Need to create as separate subquery for each Daily Time Period</span>
<span class="ruby-comment">#     so loop and build for each of them</span>
      <span class="ruby-identifier">daily_time_periods</span>.<span class="ruby-identifier">each</span> <span class="ruby-keyword">do</span> <span class="ruby-operator">|</span><span class="ruby-identifier">dtp</span><span class="ruby-operator">|</span>

<span class="ruby-comment">#       Get the start and end times as a minute of the day</span>
        <span class="ruby-identifier">start_minute</span> = <span class="ruby-identifier">time_to_minute</span> <span class="ruby-identifier">dtp</span>[<span class="ruby-value">:start_time</span>]
        <span class="ruby-identifier">end_minute</span> = <span class="ruby-identifier">time_to_minute</span> <span class="ruby-identifier">dtp</span>[<span class="ruby-value">:end_time</span>]


<span class="ruby-comment">#       Work out a subquery to find the range within a usage array to</span>
<span class="ruby-comment">#       to SUM, for usage, or MAX for maximum demand for the DTP</span>
        <span class="ruby-keyword">if</span> <span class="ruby-identifier">start_minute</span> <span class="ruby-operator">==</span> <span class="ruby-identifier">end_minute</span>
          <span class="ruby-identifier">usage_label</span> = <span class="ruby-string">&quot;-- The whole day&quot;</span>
          <span class="ruby-identifier">usage_range</span> = <span class="ruby-string">&quot;UNNEST(usage) s&quot;</span>
        <span class="ruby-keyword">elsif</span> <span class="ruby-identifier">start_minute</span> <span class="ruby-operator">&lt;</span> <span class="ruby-identifier">end_minute</span>
          <span class="ruby-identifier">usage_label</span> = <span class="ruby-string">&quot;-- Daily time period not spanning midnight&quot;</span>
          <span class="ruby-identifier">usage_range</span> = <span class="ruby-node">&quot;UNNEST(usage[#{start_minute}/interval+1 : #{end_minute}/interval]) s&quot;</span>
        <span class="ruby-keyword">else</span>
          <span class="ruby-identifier">usage_label</span> = <span class="ruby-string">&quot;-- Daily time period spanning midnight&quot;</span>
          <span class="ruby-identifier">usage_range</span> = <span class="ruby-node">&quot;UNNEST(usage[1 : #{end_minute}/interval] || usage[#{start_minute} / interval+1 : array_length(usage,1)]) s&quot;</span>
        <span class="ruby-keyword">end</span>

<span class="ruby-comment">#       Subquery to find a usage sum for this Daily Time Period</span>
        <span class="ruby-identifier">usage_sum</span> = <span class="ruby-node">&quot;
                  (
                    COALESCE
                      (
                        (
                          SELECT
                              SUM(s)
                            FROM
                              #{usage_label}
                              #{usage_range}
                        ),
                        0 -- coalesce to 0 because empty arrays return null
                      )
                  ) AS usage&quot;</span>

<span class="ruby-comment">#       Subquery to find a maximum demand for this Daily Time Period</span>
        <span class="ruby-identifier">usage_max_demand</span> = <span class="ruby-node">&quot;
                  (
                    COALESCE
                      (
                        (
                          SELECT
                              60 * MAX(s) / interval
                            FROM
                              #{usage_label}
                              #{usage_range}
                        ),
                        0 -- coalesce to 0 because empty arrays return null
                      )
                  ) AS max_demand&quot;</span>


<span class="ruby-comment">#       Now assemble the whole subquery for this DTP</span>
<span class="ruby-comment">#       This will select rows to insert as MeterAggregations</span>
        <span class="ruby-identifier">aggregations</span>.<span class="ruby-identifier">push</span>(<span class="ruby-node">&quot;
            (
--            Aggregations for #{ dtp[:label].nil? ? &#39;Entire Day&#39; : dtp[:label] }
              SELECT
                  meter_id,
                  register,
                  date,
                  TIMESTAMP &#39;#{dtp[:start_time]}&#39; as start_time,
                  TIMESTAMP &#39;#{dtp[:end_time]}&#39; as end_time,
                  --VARCHAR &#39;kwh&#39; as uom,
                  LOWER(TRIM(unit_of_measurement)) AS uom,
#{usage_sum},
#{usage_max_demand}
                FROM
                  meter_records
                WHERE
                  meter_id = ANY(&#39;{#{whitelist.keys.join(&quot;,&quot;)}}&#39;::int[])
                AND
                  ( #{date_ranges_where} )
            )
        &quot;</span>)
      <span class="ruby-keyword">end</span>

<span class="ruby-comment">#     Join each DTP&#39;s subquery with a union</span>
      <span class="ruby-identifier">aggregations</span> = <span class="ruby-identifier">aggregations</span>.<span class="ruby-identifier">join</span>(<span class="ruby-string">&quot;\n            UNION \n&quot;</span>)


<span class="ruby-comment">#     Now build the superstructure of the SQL query</span>
      <span class="ruby-identifier">sql</span> = <span class="ruby-node">&quot;
--------------------------------------------------------------------------------
--  MeterAggregation.aggregate_and_store
--  vvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvv

--  First thing, delete existing estimated aggregations for this date range and
--  these meters.

    DELETE FROM
        meter_aggregations
      WHERE
        meter_id = ANY(&#39;{#{whitelist.keys.join(&quot;,&quot;)}}&#39;::int[])
      AND
        ( #{date_ranges_where} )
      AND
        source = &#39;a&#39;;


-- Now insert aggregations using MeterRecords

    INSERT INTO meter_aggregations
      (
        meter_id,
        register,
        date,
        start_time,
        end_time,
        unit_of_measurement,
        usage,
        maximum_demand
      )

      SELECT
          meter_id,
          register,
          date,
          start_time,
          end_time,
          --uom,
          (
            CASE
#{uom_unit_cases}
              ELSE uom
            END
          ) AS uom,
          (
            CASE
#{uom_usage_cases}
              ELSE usage
            END
          ) AS usage,
          max_demand

        FROM

          (

#{aggregations}

        ORDER BY
          meter_id,
          register,
          date

    ) R

--  No overwriting or duplicating existing records
    WHERE
      NOT EXISTS
        (
          SELECT
                1
              FROM
                meter_aggregations
              WHERE
                meter_id = R.meter_id
              AND
                start_time = CAST(R.start_time as time)
              AND
                end_time = CAST(R.end_time as time)
              AND
                register = R.register
              AND
                date = R.date
        );

--  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
--  MeterAggregation.aggregate_and_store
--------------------------------------------------------------------------------
&quot;</span>

      <span class="ruby-identifier">result</span> = <span class="ruby-constant">ActiveRecord</span><span class="ruby-operator">::</span><span class="ruby-constant">Base</span>.<span class="ruby-identifier">connection</span>.<span class="ruby-identifier">raw_connection</span>.<span class="ruby-identifier">exec</span> <span class="ruby-identifier">sql</span>

    <span class="ruby-comment"># Done inserting MeterAggregations</span>
     <span class="ruby-comment">#logger.info sql</span>
    <span class="ruby-comment"># log_pg_result result</span>
    <span class="ruby-comment">################################################################################</span>

<span class="ruby-comment">#     Make up some data for any gaps</span>
      <span class="ruby-identifier">aggregate_missing_data</span> <span class="ruby-identifier">date_ranges</span>, <span class="ruby-identifier">daily_time_periods</span>, <span class="ruby-identifier">meters</span>

<span class="ruby-comment">#     Call to MeterPredictor here</span>
      <span class="ruby-identifier">date_ranges</span>.<span class="ruby-identifier">each</span> <span class="ruby-keyword">do</span> <span class="ruby-operator">|</span><span class="ruby-identifier">dr</span><span class="ruby-operator">|</span>
        <span class="ruby-constant">Meter</span>.<span class="ruby-identifier">predictor</span>.<span class="ruby-identifier">calculate</span> <span class="ruby-identifier">dr</span>[<span class="ruby-value">:start_date</span>], <span class="ruby-identifier">dr</span>[<span class="ruby-value">:end_date</span>], <span class="ruby-identifier">daily_time_periods</span>, <span class="ruby-identifier">meters</span>
      <span class="ruby-keyword">end</span>

  <span class="ruby-keyword">else</span>
      <span class="ruby-comment">#logger.info &quot;\\\\\\\\ Didn&#39;t aggregate_and_store anything&quot;</span>
    <span class="ruby-keyword">end</span>


  <span class="ruby-keyword">end</span></pre>
          </div>
          
        </div>

        

        
      </div>

    
      <div id="method-c-aggregate_missing_data" class="method-detail ">
        
        <div class="method-heading">
          <span class="method-name">aggregate_missing_data</span><span
            class="method-args">(date_ranges, daily_time_periods, meters)</span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        

        <div class="method-description">
          
          <p>Finds gaps in aggregated data and fills them with estimations</p>

<p>Author: Reuben Braithwaite</p>

<h4 id="method-c-aggregate_missing_data-label-Inputs">Inputs<span><a href="#method-c-aggregate_missing_data-label-Inputs">&para;</a> <a href="#top">&uarr;</a></span></h4>
<ul><li>
<p><code>date_ranges</code> - an array of hashes, each containing a Date
<code>start_date</code> and Date <code>end_date</code> as specified in <a
href="Meter.html">Meter</a> interface of SDD</p>
</li><li>
<p><code>daily_time_periods</code> - an array of hashes, each containing a
Time <code>start_time</code>, Time <code>end_time</code> and, optionally, a
String <code>label</code>, as specified in <a href="Meter.html">Meter</a>
interface of SDD</p>
</li><li>
<p><code>meters</code> - an array of <a href="Meter.html">Meter</a> objects</p>
</li></ul>

<h3 id="method-c-aggregate_missing_data-label-Outputs">Outputs<span><a href="#method-c-aggregate_missing_data-label-Outputs">&para;</a> <a href="#top">&uarr;</a></span></h3>

<p>None</p>
          
          

          
          <div class="method-source-code" id="aggregate_missing_data-source">
            <pre><span class="ruby-comment"># File app/models/meter_aggregation.rb, line 879</span>
  <span class="ruby-keyword">def</span> <span class="ruby-keyword">self</span>.<span class="ruby-identifier">aggregate_missing_data</span> <span class="ruby-identifier">date_ranges</span>, <span class="ruby-identifier">daily_time_periods</span>, <span class="ruby-identifier">meters</span>

<span class="ruby-comment">#   This query gets mighty big.</span>
<span class="ruby-comment">#   So I&#39;ve split the date ranges into yearly chunks</span>
<span class="ruby-comment">#   and run them 1 at a time. i.e., 1 x 5 year date range</span>
<span class="ruby-comment">#   will be converted to 5 x 1 date ranges</span>
    <span class="ruby-identifier">new_date_ranges</span> = []

    <span class="ruby-identifier">date_ranges</span>.<span class="ruby-identifier">each</span> <span class="ruby-keyword">do</span> <span class="ruby-operator">|</span><span class="ruby-identifier">dr</span><span class="ruby-operator">|</span>
      <span class="ruby-identifier">start_date</span> = <span class="ruby-identifier">dr</span>[<span class="ruby-value">:start_date</span>]
      <span class="ruby-identifier">end_date</span> = <span class="ruby-identifier">dr</span>[<span class="ruby-value">:end_date</span>]
      <span class="ruby-keyword">while</span> ( <span class="ruby-identifier">end_date</span> <span class="ruby-operator">-</span> <span class="ruby-identifier">start_date</span> <span class="ruby-operator">&gt;</span> <span class="ruby-value">365</span> ) <span class="ruby-keyword">do</span>
        <span class="ruby-identifier">new_date_ranges</span>.<span class="ruby-identifier">push</span> ({
          <span class="ruby-value">:start_date</span> =<span class="ruby-operator">&gt;</span> <span class="ruby-identifier">start_date</span>,
          <span class="ruby-value">:end_date</span> =<span class="ruby-operator">&gt;</span> <span class="ruby-identifier">start_date</span> <span class="ruby-operator">+</span> <span class="ruby-value">1</span>.<span class="ruby-identifier">year</span> <span class="ruby-operator">-</span> <span class="ruby-value">1</span>.<span class="ruby-identifier">day</span> <span class="ruby-operator">&gt;</span> <span class="ruby-identifier">end_date</span> <span class="ruby-operator">?</span> <span class="ruby-identifier">end_date</span> <span class="ruby-operator">:</span> <span class="ruby-identifier">start_date</span> <span class="ruby-operator">+</span> <span class="ruby-value">1</span>.<span class="ruby-identifier">year</span> <span class="ruby-operator">-</span> <span class="ruby-value">1</span>.<span class="ruby-identifier">day</span>
        })
        <span class="ruby-identifier">start_date</span> = <span class="ruby-identifier">start_date</span> <span class="ruby-operator">+</span> <span class="ruby-value">1</span>.<span class="ruby-identifier">year</span>
      <span class="ruby-keyword">end</span>
      <span class="ruby-identifier">new_date_ranges</span>.<span class="ruby-identifier">push</span> ({
        <span class="ruby-value">:start_date</span> =<span class="ruby-operator">&gt;</span> <span class="ruby-identifier">start_date</span>,
        <span class="ruby-value">:end_date</span> =<span class="ruby-operator">&gt;</span> <span class="ruby-identifier">start_date</span> <span class="ruby-operator">+</span> <span class="ruby-value">1</span>.<span class="ruby-identifier">year</span> <span class="ruby-operator">-</span> <span class="ruby-value">1</span>.<span class="ruby-identifier">day</span> <span class="ruby-operator">&gt;</span> <span class="ruby-identifier">end_date</span> <span class="ruby-operator">?</span> <span class="ruby-identifier">end_date</span> <span class="ruby-operator">:</span> <span class="ruby-identifier">start_date</span> <span class="ruby-operator">+</span> <span class="ruby-value">1</span>.<span class="ruby-identifier">year</span> <span class="ruby-operator">-</span> <span class="ruby-value">1</span>.<span class="ruby-identifier">day</span>
      })
    <span class="ruby-keyword">end</span>


    <span class="ruby-identifier">date_ranges</span> = <span class="ruby-identifier">new_date_ranges</span>
    <span class="ruby-identifier">new_date_ranges</span>.<span class="ruby-identifier">each</span> <span class="ruby-keyword">do</span> <span class="ruby-operator">|</span><span class="ruby-identifier">dr</span><span class="ruby-operator">|</span>

      <span class="ruby-identifier">date_ranges</span> = [<span class="ruby-identifier">dr</span>]



    <span class="ruby-identifier">whitelist</span> = <span class="ruby-constant">Meter</span>.<span class="ruby-identifier">whitelist</span> <span class="ruby-identifier">meters</span>


<span class="ruby-comment">#   Create a subquery to select each dtp</span>
<span class="ruby-comment">#   These will be cross joined with dates / meters / registers</span>
<span class="ruby-comment">#   to provide a set of missing aggregations that need to be accounted for</span>
    <span class="ruby-identifier">dtps</span> = []
    <span class="ruby-identifier">daily_time_periods</span>.<span class="ruby-identifier">each</span> <span class="ruby-keyword">do</span> <span class="ruby-operator">|</span><span class="ruby-identifier">dtp</span><span class="ruby-operator">|</span>
      <span class="ruby-identifier">dtps</span>.<span class="ruby-identifier">push</span> <span class="ruby-node">&quot;
                                  (
--                                  #{ dtp[:label].nil? ? &#39;Entire Day&#39; : dtp[:label] }
                                    SELECT
                                        TIMESTAMP &#39;#{dtp[:start_time]}&#39; as start_time,
                                        TIMESTAMP &#39;#{dtp[:end_time]}&#39; as end_time
                                  )
                            &quot;</span>
    <span class="ruby-keyword">end</span>
<span class="ruby-comment">#   ... and union those DTPs</span>
    <span class="ruby-identifier">dtps</span> = <span class="ruby-identifier">dtps</span>.<span class="ruby-identifier">join</span>(<span class="ruby-string">&quot;
                                  UNION
&quot;</span>)

<span class="ruby-comment">#   Create a subquery to generate a comprehensive set of dates in</span>
<span class="ruby-comment">#   the date ranges required</span>
    <span class="ruby-identifier">all_dates</span> = []
<span class="ruby-comment">#   and a string to use as a WHERE clause to select existing records</span>
    <span class="ruby-identifier">records_dates</span> = []
<span class="ruby-comment">#   Add the dates for each Date Range</span>
    <span class="ruby-identifier">date_ranges</span>.<span class="ruby-identifier">each</span> <span class="ruby-keyword">do</span> <span class="ruby-operator">|</span><span class="ruby-identifier">date_range</span><span class="ruby-operator">|</span>
      <span class="ruby-identifier">all_dates</span>.<span class="ruby-identifier">push</span> <span class="ruby-node">&quot;
                                          SELECT
                                              date::date
                                            FROM
                                              generate_series(
                                                &#39;#{date_range[:start_date]}&#39;,
                                                &#39;#{date_range[:end_date]}&#39;,
                                                &#39;1 day&#39;::INTERVAL
                                              ) date
&quot;</span>

      <span class="ruby-identifier">records_dates</span> = <span class="ruby-identifier">date_ranges</span>.<span class="ruby-identifier">map</span> { <span class="ruby-operator">|</span><span class="ruby-identifier">date_range</span><span class="ruby-operator">|</span> <span class="ruby-node">&quot;
                                                    (
                                                        date &gt;= &#39;#{date_range[:start_date]}&#39;
                                                      AND
                                                        date &lt;= &#39;#{date_range[:end_date]}&#39;
                                                    )
&quot;</span>}

    <span class="ruby-keyword">end</span>

    <span class="ruby-identifier">all_dates</span> = <span class="ruby-identifier">all_dates</span>.<span class="ruby-identifier">join</span>(<span class="ruby-string">&quot;              UNION&quot;</span>)
    <span class="ruby-identifier">records_dates</span> = <span class="ruby-identifier">records_dates</span>.<span class="ruby-identifier">join</span>(<span class="ruby-string">&quot;
                                                  OR&quot;</span>)



    <span class="ruby-identifier">sql</span> = <span class="ruby-node">&quot;

--------------------------------------------------------------------------------
--  MeterAggregation.aggregate_missing_data
--  vvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvv

          INSERT INTO

            meter_aggregations

              (
                meter_id,
                register,
                date,
                start_time,
                end_time,
                source,
                unit_of_measurement,
                usage,
                maximum_demand
              )

              SELECT
                  meter_id,
                  register,
                  date,
                  start_time,
                  end_time,
                  source,
                  unit_of_measurement,
                  usage,
                  (
                    CASE
                      WHEN
                        start_minute = end_minute
                      THEN
                        -- The whole day
                        60 * usage / 1440
                      WHEN
                        start_minute &lt; end_minute
                      THEN
                        -- Daily time period not spanning midnight
                        60 * usage / ( end_minute - start_minute )
                      ELSE
                        -- Daily time period spanning midnight
                        60 * usage / ( 1440 - start_minute + end_minute )
                      END
                  ) as maximum_demand
                FROM

                  (
                    SELECT
--                      Values to insert into meter_aggregations
                        meter_id,
                        register,
                        date,
                        start_time,
                        end_time,
                        &#39;a&#39; AS source,
                        COALESCE (
--                        Use the same uom as previous data if there is some
                          (
                            SELECT
                                unit_of_measurement
                            FROM
                              meter_records
                            WHERE
                              meter_id = DMRT.meter_id
                            AND
                              register = DMRT.register
                            AND
                              date = DMRT.source_date
                            LIMIT 1
                          ),
--                        Default to &#39;kwh&#39; if there&#39;s no previous data
                          &#39;kwh&#39;
                        ) AS unit_of_measurement,

                        COALESCE (
--                        When there&#39;s a valid source date to get some data from
                          (
                            SELECT
                                (
                                  CASE
                                    WHEN
                                      DMRT.start_minute = DMRT.end_minute
                                    THEN
                                      ( SELECT SUM(s) FROM UNNEST(usage) s )
                                    WHEN
                                      DMRT.start_minute &lt; DMRT.end_minute
                                    THEN
                                      ( SELECT SUM(s) FROM UNNEST(usage[DMRT.start_minute / interval+1 : DMRT.end_minute / interval]) s )
                                    ELSE
                                      ( SELECT SUM(s) FROM UNNEST(usage[1 : DMRT.start_minute/interval] || usage[DMRT.end_minute / interval + 1 : array_length(usage,1)]) s )
                                  END
                                )
                              FROM
                                meter_records
                              WHERE
                                meter_id = DMRT.meter_id
                              AND
                                register = DMRT.register
                              AND
                                date = DMRT.source_date
                              LIMIT 1
                          ),
--                        When there&#39;s NOT a valid source date to get some data from
                          (
                            CASE
                              WHEN
                                DMRT.start_minute = DMRT.end_minute
                              THEN
                                -- The whole day
                                ( 160.0 * 1000.0 ) / 365.0
                              WHEN
                                DMRT.start_minute &lt; DMRT.end_minute
                              THEN
                                -- Daily time period not spanning midnight
                                ( ( 160.0 * 1000.0 ) / 365.0 ) * ( ( DMRT.end_minute - DMRT.start_minute ) / 1440 )
                              ELSE
                                -- Daily time period spanning midnight
                                ( ( 160.0 * 1000.0 ) / 365.0 ) * ( ( 1440 - DMRT.start_minute + DMRT.end_minute ) / 1440 )
                              END
                            )
                        ) AS usage,
--                      Hang on to start/end as a number of minutes so we can
--                      use them to calculate max demand
                        start_minute,
                        end_minute
                      FROM

                        (
                          SELECT
                              meter_id,
                              register,
                              date,
                              source_date,
                              start_time,
                              end_time,
                              ( EXTRACT(MINUTE FROM start_time) + EXTRACT(HOUR FROM start_time) * 60 ) AS start_minute,
                              ( EXTRACT(MINUTE FROM end_time) + EXTRACT(HOUR FROM end_time) * 60 ) AS end_minute
                            FROM
                              (
                                (
#{dtps}
                                )
                              ) DTP

                              CROSS JOIN

                              (
                                SELECT
                                    meter_id,
                                    register,
                                    date,
--                                  Coalesce target dates here
--                                  Find the date to aggregate, if one exists
                                    COALESCE (
                                      (
                                        SELECT
                                            date
                                          FROM
                                            meter_records
                                          WHERE
                                            meter_id = CJ.meter_id
                                          AND
                                            register = CJ.register
                                          AND
                                            date = CJ.date - &#39;1 year&#39;::INTERVAL
                                      ),
                                      (
--    TODO -- this needs to loop, trying every previous billing period
--    to find a record, until 11 month prior to requested date.

                                        SELECT
                                            date
                                          FROM
                                            meter_records
                                          WHERE
                                            meter_id = CJ.meter_id
                                          AND
                                            register = CJ.register
                                          AND
                                            date = CJ.date - &#39;1 month&#39;::INTERVAL
                                      ),
                                      NULL
                                    ) AS source_date

                                  FROM

--                                  Cross Join, CJ, to get all required permutations of
--                                  date, meter and register
                                    (
--                                    Select each date we expect a record for
                                      SELECT
                                          date,
                                          meter_id,
                                          register
                                        FROM
                                          (
#{all_dates}
                                          ) D

                                          CROSS JOIN

                                          (
--                                          Unique meters / registers
                                            SELECT DISTINCT
                                                meter_id,
                                                register
                                              FROM
                                                meter_records
                                              WHERE
                                                meter_id = ANY(&#39;{#{whitelist.keys.join(&quot;,&quot;)}}&#39;::int[])
                                          ) MR

                                    ) CJ

--                                  End cross joining meters / registers / dates but
--                                  only pick those permutations that we don&#39;t have
--                                  existing records for

                                    WHERE  NOT EXISTS

                                      (
                                        SELECT
                                            1
                                          FROM
                                            (
--                                            Records that DO exist in these date ranges
                                              SELECT
                                                  meter_id,
                                                  register,
                                                  date
                                                FROM
                                                  meter_records
                                                WHERE
                                                  (
#{records_dates}
                                                  )
                                            ) R
                                          WHERE
                                            CJ.date = R.date
                                          AND
                                            CJ.meter_id = R.meter_id
                                          AND
                                            CJ.register = R.register
                                      )
                                    ORDER BY
                                      date,
                                      meter_id,
                                      register
                                  ) DMR
                          ) DMRT

                  ) MA

--  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
--  MeterAggregation.aggregate_missing_data
--------------------------------------------------------------------------------

&quot;</span>
      <span class="ruby-comment">#logger.info sql</span>
      <span class="ruby-identifier">result</span> = <span class="ruby-constant">ActiveRecord</span><span class="ruby-operator">::</span><span class="ruby-constant">Base</span>.<span class="ruby-identifier">connection</span>.<span class="ruby-identifier">raw_connection</span>.<span class="ruby-identifier">exec</span> <span class="ruby-identifier">sql</span>

    <span class="ruby-keyword">end</span>

  <span class="ruby-keyword">end</span></pre>
          </div>
          
        </div>

        

        
      </div>

    
      <div id="method-c-confidence_query" class="method-detail ">
        
        <div class="method-heading">
          <span class="method-name">confidence_query</span><span
            class="method-args">()</span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        

        <div class="method-description">
          
          <p>Gets a generic sql string to retrieve a confidence value from selected rows</p>

<p>Author: Reuben Braithwaite</p>

<h4 id="method-c-confidence_query-label-Inputs">Inputs<span><a href="#method-c-confidence_query-label-Inputs">&para;</a> <a href="#top">&uarr;</a></span></h4>

<p>None</p>

<h3 id="method-c-confidence_query-label-Outputs">Outputs<span><a href="#method-c-confidence_query-label-Outputs">&para;</a> <a href="#top">&uarr;</a></span></h3>

<p>Returns a sql string</p>
          
          

          
          <div class="method-source-code" id="confidence_query-source">
            <pre><span class="ruby-comment"># File app/models/meter_aggregation.rb, line 449</span>
<span class="ruby-keyword">def</span> <span class="ruby-keyword">self</span>.<span class="ruby-identifier">confidence_query</span>
  <span class="ruby-keyword">return</span> <span class="ruby-string">&quot;
          ROUND(
            (
              SUM(
                CASE
                  WHEN
                    source = &#39;r&#39;
                  THEN
                    1.0
                  ELSE
                    0.0
                  END
              ) / COUNT(usage) ), 1
          )&quot;</span>
<span class="ruby-keyword">end</span></pre>
          </div>
          
        </div>

        

        
      </div>

    
      <div id="method-c-daily_full_usage_sums" class="method-detail ">
        
        <div class="method-heading">
          <span class="method-name">daily_full_usage_sums</span><span
            class="method-args">(date_range, whitelist)</span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        

        <div class="method-description">
          
          <p>Returns a set of daily usage totals for the Given Date range and Meters</p>

<p>Author: Reuben Braithwaite</p>

<h4 id="method-c-daily_full_usage_sums-label-Inputs">Inputs<span><a href="#method-c-daily_full_usage_sums-label-Inputs">&para;</a> <a href="#top">&uarr;</a></span></h4>
<ul><li>
<p><code>date_range</code> -  Date <code>start_date</code> and Date
<code>end_date</code></p>
</li><li>
<p><code>whitelist</code> - hash of meter_id =&gt; meter_serial tuples</p>
</li></ul>

<h3 id="method-c-daily_full_usage_sums-label-Outputs">Outputs<span><a href="#method-c-daily_full_usage_sums-label-Outputs">&para;</a> <a href="#top">&uarr;</a></span></h3>

<p>returns a array of hashes, containing daily total usage data</p>
          
          

          
          <div class="method-source-code" id="daily_full_usage_sums-source">
            <pre><span class="ruby-comment"># File app/models/meter_aggregation.rb, line 525</span>
<span class="ruby-keyword">def</span> <span class="ruby-keyword">self</span>.<span class="ruby-identifier">daily_full_usage_sums</span> <span class="ruby-identifier">date_range</span>, <span class="ruby-identifier">whitelist</span>
  <span class="ruby-identifier">dtps</span> = [
    {
      <span class="ruby-value">:start_time</span> =<span class="ruby-operator">&gt;</span> <span class="ruby-identifier">all_day</span>[<span class="ruby-value">:start_time</span>],
      <span class="ruby-value">:end_time</span> =<span class="ruby-operator">&gt;</span> <span class="ruby-identifier">all_day</span>[<span class="ruby-value">:end_time</span>]
    }
  ]
  <span class="ruby-keyword">return</span> <span class="ruby-identifier">daily_usage_sums</span> <span class="ruby-identifier">date_range</span>, <span class="ruby-identifier">dtps</span>, <span class="ruby-identifier">whitelist</span>
<span class="ruby-keyword">end</span></pre>
          </div>
          
        </div>

        

        
      </div>

    
      <div id="method-c-daily_usage_hash" class="method-detail ">
        
        <div class="method-heading">
          <span class="method-name">daily_usage_hash</span><span
            class="method-args">(result)</span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        

        <div class="method-description">
          
          <p>Formats and returns a hash of daily usages per date</p>

<p>Author: Reuben Braithwaite</p>

<h4 id="method-c-daily_usage_hash-label-Inputs">Inputs<span><a href="#method-c-daily_usage_hash-label-Inputs">&para;</a> <a href="#top">&uarr;</a></span></h4>
<ul><li>
<p><code>result</code> -  pgsql result of a usage query</p>
</li></ul>

<h3 id="method-c-daily_usage_hash-label-Outputs">Outputs<span><a href="#method-c-daily_usage_hash-label-Outputs">&para;</a> <a href="#top">&uarr;</a></span></h3>

<p>Returns a array of hashes, containing daily usage data</p>
          
          

          
          <div class="method-source-code" id="daily_usage_hash-source">
            <pre><span class="ruby-comment"># File app/models/meter_aggregation.rb, line 590</span>
<span class="ruby-keyword">def</span> <span class="ruby-keyword">self</span>.<span class="ruby-identifier">daily_usage_hash</span> <span class="ruby-identifier">result</span>
  <span class="ruby-identifier">result</span>.<span class="ruby-identifier">map</span> <span class="ruby-keyword">do</span> <span class="ruby-operator">|</span><span class="ruby-identifier">r</span><span class="ruby-operator">|</span> {
      <span class="ruby-value">:date</span> =<span class="ruby-operator">&gt;</span> <span class="ruby-identifier">r</span>[<span class="ruby-string">&quot;date&quot;</span>].<span class="ruby-identifier">to_date</span>,
      <span class="ruby-value">:usage</span> =<span class="ruby-operator">&gt;</span> <span class="ruby-identifier">r</span>[<span class="ruby-string">&quot;usage&quot;</span>].<span class="ruby-identifier">to_f</span>,
      <span class="ruby-value">:confidence</span> =<span class="ruby-operator">&gt;</span> <span class="ruby-identifier">r</span>[<span class="ruby-string">&quot;confidence&quot;</span>].<span class="ruby-identifier">to_f</span>,
      <span class="ruby-value">:maximum_demand</span> =<span class="ruby-operator">&gt;</span> <span class="ruby-identifier">r</span>[<span class="ruby-string">&quot;maximum_demand&quot;</span>].<span class="ruby-identifier">to_f</span>
    }
  <span class="ruby-keyword">end</span>
<span class="ruby-keyword">end</span></pre>
          </div>
          
        </div>

        

        
      </div>

    
      <div id="method-c-daily_usage_sums" class="method-detail ">
        
        <div class="method-heading">
          <span class="method-name">daily_usage_sums</span><span
            class="method-args">(date_range, daily_time_periods, whitelist)</span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        

        <div class="method-description">
          
          <p>Gets the daily usages for all meters in the whitelist and for the date
range specified.</p>

<p>Author: Reuben Braithwaite</p>

<h4 id="method-c-daily_usage_sums-label-Inputs">Inputs<span><a href="#method-c-daily_usage_sums-label-Inputs">&para;</a> <a href="#top">&uarr;</a></span></h4>
<ul><li>
<p><code>date_range</code> -  Date <code>start_date</code> and Date
<code>end_date</code></p>
</li><li>
<p><code>daily_time_periods</code> - an array of daily time periods, each
specified by <code>:start_time</code> and <code>:end_time</code></p>
</li><li>
<p><code>whitelist</code> - hash of meter_id =&gt; meter_serial tuples</p>
</li></ul>

<h3 id="method-c-daily_usage_sums-label-Outputs">Outputs<span><a href="#method-c-daily_usage_sums-label-Outputs">&para;</a> <a href="#top">&uarr;</a></span></h3>

<p>returns a array of hashes, containing top-level total usage data</p>
          
          

          
          <div class="method-source-code" id="daily_usage_sums-source">
            <pre><span class="ruby-comment"># File app/models/meter_aggregation.rb, line 550</span>
<span class="ruby-keyword">def</span> <span class="ruby-keyword">self</span>.<span class="ruby-identifier">daily_usage_sums</span> <span class="ruby-identifier">date_range</span>, <span class="ruby-identifier">daily_time_periods</span>, <span class="ruby-identifier">whitelist</span>

  <span class="ruby-identifier">dtps</span> = []
  <span class="ruby-identifier">daily_time_periods</span>. <span class="ruby-identifier">each</span> <span class="ruby-keyword">do</span> <span class="ruby-operator">|</span><span class="ruby-identifier">dtp</span><span class="ruby-operator">|</span>
    <span class="ruby-identifier">dtps</span>.<span class="ruby-identifier">push</span> <span class="ruby-node">&quot;( start_time = &#39;#{dtp[:start_time]}&#39; AND end_time = &#39;#{dtp[:end_time]}&#39; )&quot;</span>
  <span class="ruby-keyword">end</span>

  <span class="ruby-identifier">sql</span> = <span class="ruby-node">&quot;SELECT
          date,
          SUM(usage) as usage,
          #{confidence_query} AS confidence,
          SUM(maximum_demand) as maximum_demand
        FROM
          meter_aggregations
        WHERE
          meter_id = ANY(&#39;{#{whitelist.keys.join(&quot;,&quot;)}}&#39;::int[])
        AND
          ( date &gt;= &#39;#{date_range[:start_date]}&#39; AND date &lt;= &#39;#{date_range[:end_date]}&#39; )
        AND
          (
          #{dtps.join(&quot; OR &quot;)}
          )
        GROUP BY date
        ORDER BY date;&quot;</span>
  <span class="ruby-comment">#logger.info sql</span>

  <span class="ruby-identifier">result</span> = <span class="ruby-constant">ActiveRecord</span><span class="ruby-operator">::</span><span class="ruby-constant">Base</span>.<span class="ruby-identifier">connection</span>.<span class="ruby-identifier">raw_connection</span>.<span class="ruby-identifier">exec</span> <span class="ruby-identifier">sql</span>
  <span class="ruby-keyword">return</span> <span class="ruby-identifier">daily_usage_hash</span> <span class="ruby-identifier">result</span>
<span class="ruby-keyword">end</span></pre>
          </div>
          
        </div>

        

        
      </div>

    
      <div id="method-c-dtp_meter_usage" class="method-detail ">
        
        <div class="method-heading">
          <span class="method-name">dtp_meter_usage</span><span
            class="method-args">(date_range, dtp, whitelist, options)</span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        

        <div class="method-description">
          
          <p>Gets an array of usage data hashes for the given Daily Time Period, and
broken down by <a href="Meter.html">Meter</a></p>

<p>Author: Reuben Braithwaite</p>

<h4 id="method-c-dtp_meter_usage-label-Inputs">Inputs<span><a href="#method-c-dtp_meter_usage-label-Inputs">&para;</a> <a href="#top">&uarr;</a></span></h4>
<ul><li>
<p><code>date_range</code> - a hash containing a Date <code>:start_date</code>
and Date <code>:end_date</code> as specified in <a
href="Meter.html">Meter</a> interface of SDD</p>
</li><li>
<p><code>dtp</code> - the daily time period, specified by
<code>:start_time</code> and <code>:end_time</code></p>
</li><li>
<p><code>whitelist</code> - hash of meter_id =&gt; meter_serial tuples</p>
</li><li>
<p><code>options</code> - hash of boolean options – detailed</p>
</li></ul>

<h3 id="method-c-dtp_meter_usage-label-Outputs">Outputs<span><a href="#method-c-dtp_meter_usage-label-Outputs">&para;</a> <a href="#top">&uarr;</a></span></h3>

<p>returns an array, containing usage for the DTP broken down by meter</p>
          
          

          
          <div class="method-source-code" id="dtp_meter_usage-source">
            <pre><span class="ruby-comment"># File app/models/meter_aggregation.rb, line 175</span>
<span class="ruby-keyword">def</span> <span class="ruby-keyword">self</span>.<span class="ruby-identifier">dtp_meter_usage</span> <span class="ruby-identifier">date_range</span>, <span class="ruby-identifier">dtp</span>, <span class="ruby-identifier">whitelist</span>, <span class="ruby-identifier">options</span>

  <span class="ruby-identifier">usages</span> = <span class="ruby-identifier">dtp_meter_usage_sums</span> <span class="ruby-identifier">date_range</span>, <span class="ruby-identifier">dtp</span>, <span class="ruby-identifier">whitelist</span>
  <span class="ruby-identifier">usages</span>.<span class="ruby-identifier">each</span> <span class="ruby-keyword">do</span> <span class="ruby-operator">|</span><span class="ruby-identifier">usage</span><span class="ruby-operator">|</span>
    <span class="ruby-identifier">shortlist</span> = { <span class="ruby-identifier">whitelist</span>.<span class="ruby-identifier">key</span>(<span class="ruby-identifier">usage</span>[<span class="ruby-value">:serial</span>]) =<span class="ruby-operator">&gt;</span> <span class="ruby-identifier">usage</span>[<span class="ruby-value">:serial</span>] }
    <span class="ruby-keyword">if</span> <span class="ruby-identifier">options</span>[<span class="ruby-value">:detailed</span>] <span class="ruby-keyword">then</span>
      <span class="ruby-identifier">usage</span>[<span class="ruby-value">:daily_usage</span>] = <span class="ruby-identifier">daily_usage_sums</span> <span class="ruby-identifier">date_range</span>, <span class="ruby-identifier">dtp</span>, <span class="ruby-identifier">shortlist</span>
    <span class="ruby-keyword">end</span>
  <span class="ruby-keyword">end</span>

  <span class="ruby-keyword">return</span> <span class="ruby-identifier">usages</span>
<span class="ruby-keyword">end</span></pre>
          </div>
          
        </div>

        

        
      </div>

    
      <div id="method-c-dtp_meter_usage_sums" class="method-detail ">
        
        <div class="method-heading">
          <span class="method-name">dtp_meter_usage_sums</span><span
            class="method-args">(date_range, dtps, whitelist)</span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        

        <div class="method-description">
          
          <p>Gets the total usage each meter in the whitelist and for the date range
specified. Returns a float.</p>

<p>Author: Reuben Braithwaite</p>

<h4 id="method-c-dtp_meter_usage_sums-label-Inputs">Inputs<span><a href="#method-c-dtp_meter_usage_sums-label-Inputs">&para;</a> <a href="#top">&uarr;</a></span></h4>
<ul><li>
<p><code>date_range</code> -  Date <code>start_date</code> and Date
<code>end_date</code></p>
</li><li>
<p><code>dtps</code> - an array of daily time periods, eachspecified by
<code>:start_time</code> and <code>:end_time</code></p>
</li><li>
<p><code>whitelist</code> - hash of meter_id =&gt; meter_serial tuples</p>
</li></ul>

<h3 id="method-c-dtp_meter_usage_sums-label-Outputs">Outputs<span><a href="#method-c-dtp_meter_usage_sums-label-Outputs">&para;</a> <a href="#top">&uarr;</a></span></h3>

<p>returns a array of hashes, containing meter-level total usage data</p>
          
          

          
          <div class="method-source-code" id="dtp_meter_usage_sums-source">
            <pre><span class="ruby-comment"># File app/models/meter_aggregation.rb, line 280</span>
<span class="ruby-keyword">def</span> <span class="ruby-keyword">self</span>.<span class="ruby-identifier">dtp_meter_usage_sums</span> <span class="ruby-identifier">date_range</span>, <span class="ruby-identifier">dtps</span>, <span class="ruby-identifier">whitelist</span>
  <span class="ruby-identifier">dtp_query</span> = []
  <span class="ruby-identifier">dtps</span>.<span class="ruby-identifier">each</span> <span class="ruby-keyword">do</span> <span class="ruby-operator">|</span><span class="ruby-identifier">dtp</span><span class="ruby-operator">|</span>
    <span class="ruby-identifier">dtp_query</span>.<span class="ruby-identifier">push</span> <span class="ruby-node">&quot;( start_time = &#39;#{dtp[:start_time]}&#39; AND end_time = &#39;#{dtp[:end_time]}&#39; )&quot;</span>
  <span class="ruby-keyword">end</span>

  <span class="ruby-identifier">sql</span> = <span class="ruby-node">&quot;SELECT
            serial,
            SUM(usage) AS usage,
            #{confidence_query} AS confidence,
            MAX(maximum_demand) as maximum_demand,
            TRIM(unit_of_measurement) as uom
          FROM
            meter_aggregations AS MA INNER JOIN meters AS M ON M.id = MA.meter_id
          WHERE
              meter_id = ANY(&#39;{#{whitelist.keys.join(&quot;,&quot;)}}&#39;::int[])
            AND
              ( date &gt;= &#39;#{date_range[:start_date]}&#39; AND date &lt;= &#39;#{date_range[:end_date]}&#39; )
            AND
              (
                #{dtp_query.join(&quot; OR &quot;)}
              )
          GROUP BY serial, uom
          ORDER BY serial;&quot;</span>

  <span class="ruby-identifier">result</span> = <span class="ruby-constant">ActiveRecord</span><span class="ruby-operator">::</span><span class="ruby-constant">Base</span>.<span class="ruby-identifier">connection</span>.<span class="ruby-identifier">raw_connection</span>.<span class="ruby-identifier">exec</span> <span class="ruby-identifier">sql</span>
  <span class="ruby-identifier">result</span>.<span class="ruby-identifier">map</span> <span class="ruby-keyword">do</span>
    <span class="ruby-operator">|</span><span class="ruby-identifier">r</span><span class="ruby-operator">|</span> {
      <span class="ruby-value">:serial</span> =<span class="ruby-operator">&gt;</span> <span class="ruby-identifier">r</span>[<span class="ruby-string">&quot;serial&quot;</span>],
      <span class="ruby-value">:usage</span> =<span class="ruby-operator">&gt;</span> <span class="ruby-identifier">r</span>[<span class="ruby-string">&quot;usage&quot;</span>].<span class="ruby-identifier">to_f</span>,
      <span class="ruby-value">:confidence</span> =<span class="ruby-operator">&gt;</span> <span class="ruby-identifier">r</span>[<span class="ruby-string">&quot;confidence&quot;</span>].<span class="ruby-identifier">to_f</span>,
      <span class="ruby-value">:maximum_demand</span> =<span class="ruby-operator">&gt;</span> <span class="ruby-identifier">r</span>[<span class="ruby-string">&quot;maximum_demand&quot;</span>].<span class="ruby-identifier">to_f</span>,
      <span class="ruby-value">:uom</span> =<span class="ruby-operator">&gt;</span> <span class="ruby-identifier">r</span>[<span class="ruby-string">&quot;uom&quot;</span>]
    }
  <span class="ruby-keyword">end</span>
<span class="ruby-keyword">end</span></pre>
          </div>
          
        </div>

        

        
      </div>

    
      <div id="method-c-dtp_usage" class="method-detail ">
        
        <div class="method-heading">
          <span class="method-name">dtp_usage</span><span
            class="method-args">(date_range, dtps, whitelist, options)</span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        

        <div class="method-description">
          
          <p>Gets an array of usage data hashes for the given Daily Time Periods, and
broken down by <a href="Meter.html">Meter</a></p>

<p>Author: Reuben Braithwaite</p>

<h4 id="method-c-dtp_usage-label-Inputs">Inputs<span><a href="#method-c-dtp_usage-label-Inputs">&para;</a> <a href="#top">&uarr;</a></span></h4>
<ul><li>
<p><code>date_range</code> - a hash containing a Date <code>:start_date</code>
and Date <code>:end_date</code> as specified in <a
href="Meter.html">Meter</a> interface of SDD</p>
</li><li>
<p><code>dtps</code> - an array of daily time periods, eachspecified by
<code>:start_time</code> and <code>:end_time</code></p>
</li><li>
<p><code>whitelist</code> - hash of meter_id =&gt; meter_serial tuples</p>
</li><li>
<p><code>options</code> - hash of boolean options – detailed</p>
</li></ul>

<h3 id="method-c-dtp_usage-label-Outputs">Outputs<span><a href="#method-c-dtp_usage-label-Outputs">&para;</a> <a href="#top">&uarr;</a></span></h3>

<p>returns an array, containing usage for the DTP broken down by meter</p>
          
          

          
          <div class="method-source-code" id="dtp_usage-source">
            <pre><span class="ruby-comment"># File app/models/meter_aggregation.rb, line 203</span>
<span class="ruby-keyword">def</span> <span class="ruby-keyword">self</span>.<span class="ruby-identifier">dtp_usage</span> <span class="ruby-identifier">date_range</span>, <span class="ruby-identifier">dtps</span>, <span class="ruby-identifier">whitelist</span>, <span class="ruby-identifier">options</span>
  <span class="ruby-identifier">usages</span> = <span class="ruby-identifier">total_dtp_usage_sums</span> <span class="ruby-identifier">date_range</span>, <span class="ruby-identifier">dtps</span>, <span class="ruby-identifier">whitelist</span>
  <span class="ruby-identifier">suboptions</span> = <span class="ruby-identifier">options</span>.<span class="ruby-identifier">clone</span>
  <span class="ruby-identifier">suboptions</span>[<span class="ruby-value">:nest</span>] = <span class="ruby-keyword">false</span>
  <span class="ruby-identifier">usages</span>.<span class="ruby-identifier">each</span> <span class="ruby-keyword">do</span> <span class="ruby-operator">|</span><span class="ruby-identifier">usage</span><span class="ruby-operator">|</span>
    <span class="ruby-identifier">dtp</span> = [ { <span class="ruby-value">:start_time</span> =<span class="ruby-operator">&gt;</span> <span class="ruby-identifier">usage</span>[<span class="ruby-value">:start_time</span>], <span class="ruby-value">:end_time</span> =<span class="ruby-operator">&gt;</span> <span class="ruby-identifier">usage</span>[<span class="ruby-value">:end_time</span>] } ]

    <span class="ruby-keyword">if</span> <span class="ruby-identifier">options</span>[<span class="ruby-value">:detailed</span>] <span class="ruby-keyword">then</span>
      <span class="ruby-identifier">usage</span>[<span class="ruby-value">:daily_usage</span>] = <span class="ruby-identifier">daily_usage_sums</span> <span class="ruby-identifier">date_range</span>, <span class="ruby-identifier">dtp</span>, <span class="ruby-identifier">whitelist</span>

    <span class="ruby-keyword">end</span>
    <span class="ruby-keyword">if</span> <span class="ruby-identifier">options</span>[<span class="ruby-value">:nest</span>] <span class="ruby-keyword">then</span>
      <span class="ruby-identifier">usage</span>[<span class="ruby-value">:meters</span>] = <span class="ruby-identifier">dtp_meter_usage</span> <span class="ruby-identifier">date_range</span>, <span class="ruby-identifier">dtp</span>, <span class="ruby-identifier">whitelist</span>, <span class="ruby-identifier">suboptions</span>
    <span class="ruby-keyword">end</span>
  <span class="ruby-keyword">end</span>
  <span class="ruby-keyword">return</span> <span class="ruby-identifier">usages</span>
<span class="ruby-keyword">end</span></pre>
          </div>
          
        </div>

        

        
      </div>

    
      <div id="method-c-inclusive_usage" class="method-detail ">
        
        <div class="method-heading">
          <span class="method-name">inclusive_usage</span><span
            class="method-args">(date_ranges, meters, detailed)</span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        

        <div class="method-description">
          
          <p>Gets an array of top level, inclusive usage data hashes As per spec
Interface08, usage data in the top level of both returnable examples</p>

<p>Author: Reuben Braithwaite</p>

<h4 id="method-c-inclusive_usage-label-Inputs">Inputs<span><a href="#method-c-inclusive_usage-label-Inputs">&para;</a> <a href="#top">&uarr;</a></span></h4>
<ul><li>
<p><code>date_ranges</code> - an array of hashes, each containing a Date
<code>start_date</code> and Date <code>end_date</code> as specified in <a
href="Meter.html">Meter</a> interface of SDD</p>
</li><li>
<p><code>daily_time_periods</code> - an array of hashes, each containing a
Time <code>start_time</code>, Time <code>end_time</code> and, optionally, a
String <code>label</code>, as specified in <a href="Meter.html">Meter</a>
interface of SDD</p>
</li><li>
<p><code>meters</code> - an array of <a href="Meter.html">Meter</a> objects</p>
</li><li>
<p><code>detailed</code> - boolean, defaults to false</p>
</li></ul>

<h3 id="method-c-inclusive_usage-label-Outputs">Outputs<span><a href="#method-c-inclusive_usage-label-Outputs">&para;</a> <a href="#top">&uarr;</a></span></h3>

<p>returns a hash, containing top-level usage data</p>
          
          

          
          <div class="method-source-code" id="inclusive_usage-source">
            <pre><span class="ruby-comment"># File app/models/meter_aggregation.rb, line 99</span>
<span class="ruby-keyword">def</span> <span class="ruby-keyword">self</span>.<span class="ruby-identifier">inclusive_usage</span> <span class="ruby-identifier">date_ranges</span>, <span class="ruby-identifier">meters</span>, <span class="ruby-identifier">detailed</span>
  <span class="ruby-identifier">whitelist</span> = <span class="ruby-constant">Meter</span>.<span class="ruby-identifier">whitelist</span> <span class="ruby-identifier">meters</span>
  <span class="ruby-identifier">usages</span> = []
  <span class="ruby-identifier">date_ranges</span>.<span class="ruby-identifier">each</span> <span class="ruby-keyword">do</span> <span class="ruby-operator">|</span><span class="ruby-identifier">date_range</span><span class="ruby-operator">|</span>

    <span class="ruby-identifier">usage</span> = {
      <span class="ruby-value">:retrieved</span> =<span class="ruby-operator">&gt;</span> <span class="ruby-constant">Time</span>.<span class="ruby-identifier">now</span>.<span class="ruby-identifier">to_s</span>,
      <span class="ruby-value">:start_date</span> =<span class="ruby-operator">&gt;</span> <span class="ruby-identifier">date_range</span>[<span class="ruby-value">:start_date</span>],
      <span class="ruby-value">:end_date</span> =<span class="ruby-operator">&gt;</span> <span class="ruby-identifier">date_range</span>[<span class="ruby-value">:end_date</span>],
    }

    <span class="ruby-identifier">usage</span> = (<span class="ruby-identifier">total_usage_sums</span> <span class="ruby-identifier">date_range</span>, <span class="ruby-identifier">whitelist</span>).<span class="ruby-identifier">merge</span>(<span class="ruby-identifier">usage</span>)

    <span class="ruby-keyword">if</span> <span class="ruby-identifier">detailed</span> <span class="ruby-keyword">then</span>
      <span class="ruby-identifier">usage</span>[<span class="ruby-value">:daily_usage</span>] = ( <span class="ruby-identifier">daily_full_usage_sums</span> <span class="ruby-identifier">date_range</span>, <span class="ruby-identifier">whitelist</span> )
    <span class="ruby-keyword">end</span>
    <span class="ruby-identifier">usages</span>.<span class="ruby-identifier">push</span> <span class="ruby-identifier">usage</span>
  <span class="ruby-keyword">end</span>
  <span class="ruby-keyword">return</span> <span class="ruby-identifier">usages</span>
<span class="ruby-keyword">end</span></pre>
          </div>
          
        </div>

        

        
      </div>

    
      <div id="method-c-meter_usage" class="method-detail ">
        
        <div class="method-heading">
          <span class="method-name">meter_usage</span><span
            class="method-args">(date_range, dtps, whitelist, options)</span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        

        <div class="method-description">
          
          <p>Gets an array of usage data hashes by <a href="Meter.html">Meter</a></p>

<p>Author: Reuben Braithwaite</p>

<h4 id="method-c-meter_usage-label-Inputs">Inputs<span><a href="#method-c-meter_usage-label-Inputs">&para;</a> <a href="#top">&uarr;</a></span></h4>
<ul><li>
<p><code>date_ranges</code> - an array of hashes, each containing a Date
<code>start_date</code> and Date <code>end_date</code> as specified in <a
href="Meter.html">Meter</a> interface of SDD</p>
</li><li>
<p><code>daily_time_periods</code> - an array of hashes, each containing a
Time <code>start_time</code>, Time <code>end_time</code> and, optionally, a
String <code>label</code>, as specified in <a href="Meter.html">Meter</a>
interface of SDD</p>
</li><li>
<p><code>whitelist</code> - hash of meter_id =&gt; meter_serial tuples</p>
</li><li>
<p><code>options</code> - hash of boolean options – detailed, whether to nest
further usage data</p>
</li></ul>

<h3 id="method-c-meter_usage-label-Outputs">Outputs<span><a href="#method-c-meter_usage-label-Outputs">&para;</a> <a href="#top">&uarr;</a></span></h3>

<p>returns a hash, containing meter-level usage data</p>
          
          

          
          <div class="method-source-code" id="meter_usage-source">
            <pre><span class="ruby-comment"># File app/models/meter_aggregation.rb, line 141</span>
<span class="ruby-keyword">def</span> <span class="ruby-keyword">self</span>.<span class="ruby-identifier">meter_usage</span> <span class="ruby-identifier">date_range</span>, <span class="ruby-identifier">dtps</span>, <span class="ruby-identifier">whitelist</span>, <span class="ruby-identifier">options</span>

  <span class="ruby-identifier">suboptions</span> = <span class="ruby-identifier">options</span>.<span class="ruby-identifier">clone</span>
  <span class="ruby-identifier">suboptions</span>[<span class="ruby-value">:nest</span>] = <span class="ruby-keyword">false</span>

  <span class="ruby-identifier">usages</span> = <span class="ruby-identifier">total_meter_usage_sums</span> <span class="ruby-identifier">date_range</span>, <span class="ruby-identifier">whitelist</span>

  <span class="ruby-identifier">usages</span>.<span class="ruby-identifier">each</span> <span class="ruby-keyword">do</span> <span class="ruby-operator">|</span><span class="ruby-identifier">usage</span><span class="ruby-operator">|</span>
    <span class="ruby-identifier">shortlist</span> = { <span class="ruby-identifier">whitelist</span>.<span class="ruby-identifier">key</span>(<span class="ruby-identifier">usage</span>[<span class="ruby-value">:serial</span>]) =<span class="ruby-operator">&gt;</span> <span class="ruby-identifier">usage</span>[<span class="ruby-value">:serial</span>] }

    <span class="ruby-keyword">if</span> <span class="ruby-identifier">options</span>[<span class="ruby-value">:detailed</span>] <span class="ruby-keyword">then</span>
      <span class="ruby-identifier">usage</span>[<span class="ruby-value">:daily_usage</span>] = <span class="ruby-identifier">daily_full_usage_sums</span> <span class="ruby-identifier">date_range</span>, <span class="ruby-identifier">shortlist</span>
    <span class="ruby-keyword">end</span>
    <span class="ruby-keyword">if</span> <span class="ruby-identifier">options</span>[<span class="ruby-value">:nest</span>] <span class="ruby-keyword">and</span> (<span class="ruby-keyword">not</span> <span class="ruby-identifier">dtps</span>.<span class="ruby-identifier">empty?</span>) <span class="ruby-keyword">then</span>
      <span class="ruby-identifier">usage</span>[<span class="ruby-value">:daily_time_periods</span>] = <span class="ruby-identifier">dtp_usage</span> <span class="ruby-identifier">date_range</span>, <span class="ruby-identifier">dtps</span>, <span class="ruby-identifier">shortlist</span>, <span class="ruby-identifier">suboptions</span>
    <span class="ruby-keyword">end</span>
  <span class="ruby-keyword">end</span>
  <span class="ruby-keyword">return</span> <span class="ruby-identifier">usages</span>
<span class="ruby-keyword">end</span></pre>
          </div>
          
        </div>

        

        
      </div>

    
      <div id="method-c-total_dtp_usage_sums" class="method-detail ">
        
        <div class="method-heading">
          <span class="method-name">total_dtp_usage_sums</span><span
            class="method-args">(date_range, daily_time_periods, whitelist)</span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        

        <div class="method-description">
          
          <p>Gets the total usage each meter in the whitelist and for the date range
specified. Gets the total usage each meter in the whitelist and for the
date range specified. Returns a float.</p>

<p>Author: Reuben Braithwaite</p>

<h4 id="method-c-total_dtp_usage_sums-label-Inputs">Inputs<span><a href="#method-c-total_dtp_usage_sums-label-Inputs">&para;</a> <a href="#top">&uarr;</a></span></h4>
<ul><li>
<p><code>date_range</code> -  Date <code>start_date</code> and Date
<code>end_date</code></p>
</li><li>
<p><code>dtps</code> - an array of daily time periods, eachspecified by
<code>:start_time</code> and <code>:end_time</code></p>
</li><li>
<p><code>whitelist</code> - hash of meter_id =&gt; meter_serial tuples</p>
</li></ul>

<h3 id="method-c-total_dtp_usage_sums-label-Outputs">Outputs<span><a href="#method-c-total_dtp_usage_sums-label-Outputs">&para;</a> <a href="#top">&uarr;</a></span></h3>

<p>returns a array of hashes, containing dtp-level total usage data</p>
          
          

          
          <div class="method-source-code" id="total_dtp_usage_sums-source">
            <pre><span class="ruby-comment"># File app/models/meter_aggregation.rb, line 333</span>
  <span class="ruby-keyword">def</span> <span class="ruby-keyword">self</span>.<span class="ruby-identifier">total_dtp_usage_sums</span> <span class="ruby-identifier">date_range</span>, <span class="ruby-identifier">daily_time_periods</span>, <span class="ruby-identifier">whitelist</span>
    <span class="ruby-identifier">specified_dtps</span> = []
    <span class="ruby-identifier">dtps</span> = []
    <span class="ruby-identifier">daily_time_periods</span>. <span class="ruby-identifier">each</span> <span class="ruby-keyword">do</span> <span class="ruby-operator">|</span><span class="ruby-identifier">dtp</span><span class="ruby-operator">|</span>
      <span class="ruby-identifier">dtps</span>.<span class="ruby-identifier">push</span> <span class="ruby-node">&quot;( start_time = &#39;#{dtp[:start_time]}&#39; AND end_time = &#39;#{dtp[:end_time]}&#39; )&quot;</span>
      <span class="ruby-identifier">specified_dtps</span>.<span class="ruby-identifier">push</span> <span class="ruby-node">&quot;
                  (
                    SELECT
                      CAST(&#39;#{dtp[:start_time]}&#39; as time) AS start_time,
                      CAST(&#39;#{dtp[:end_time]}&#39; as time) AS end_time,
                      &#39;#{dtp[:label]}&#39; AS label
                  )&quot;</span>
    <span class="ruby-keyword">end</span>
      <span class="ruby-identifier">specified_dtps</span> = <span class="ruby-identifier">specified_dtps</span>.<span class="ruby-identifier">join</span>(<span class="ruby-string">&quot;
                  UNION
&quot;</span>)

    <span class="ruby-identifier">sql</span> = <span class="ruby-node">&quot;
          SELECT
              *
            FROM
--            DTPs
              (
                SELECT
                  start_time,
                  end_time,
                  SUM(usage) AS usage,
                  #{confidence_query} AS confidence,
                  TRIM(unit_of_measurement) as uom
                FROM
                  meter_aggregations
                WHERE
                  meter_id = ANY(&#39;{#{whitelist.keys.join(&quot;,&quot;)}}&#39;::int[])
                AND
                  ( date &gt;= &#39;#{date_range[:start_date]}&#39; AND date &lt;= &#39;#{date_range[:end_date]}&#39; )
                AND
                  (
                    #{dtps.join(&quot; OR &quot;)}
                  )
                GROUP BY start_time, end_time, uom
              ) DTP
--            End DTPs

              NATURAL JOIN

--            Maximum Demand per DTP
              (

                SELECT
                    SUM(maximum_demand) as maximum_demand,
                    start_time,
                    end_time
                  FROM
                    (
                      SELECT
                          start_time,
                          end_time,
                          serial,
                          MAX(maximum_demand) as maximum_demand
                        FROM
                          meter_aggregations AS MA INNER JOIN meters AS M ON M.id = MA.meter_id
                        WHERE
                          meter_id = ANY(&#39;{#{whitelist.keys.join(&quot;,&quot;)}}&#39;::int[])
                        AND
                          ( date &gt;= &#39;#{date_range[:start_date]}&#39; AND date &lt;= &#39;#{date_range[:end_date]}&#39; )
                        AND
                          (
                            #{dtps.join(&quot; OR &quot;)}
                          )
                        GROUP BY start_time, end_time, serial
                      ) MD1
                  GROUP BY start_time, end_time
              ) MD
--            End Maximum Demand per DTP

              NATURAL JOIN

--            Specified, labelled DTPs
--            This is necessary when multiple specified DTPs
--            have the same values for start and end times
              (

                #{specified_dtps}

              ) L
--            Specified, labelled DTPs

            ORDER BY start_time, end_time;&quot;</span>

    <span class="ruby-comment">#logger.info sql</span>
    <span class="ruby-identifier">result</span> = <span class="ruby-constant">ActiveRecord</span><span class="ruby-operator">::</span><span class="ruby-constant">Base</span>.<span class="ruby-identifier">connection</span>.<span class="ruby-identifier">raw_connection</span>.<span class="ruby-identifier">exec</span> <span class="ruby-identifier">sql</span>

    <span class="ruby-keyword">return</span> <span class="ruby-identifier">result</span>.<span class="ruby-identifier">map</span> <span class="ruby-keyword">do</span>
      <span class="ruby-operator">|</span><span class="ruby-identifier">r</span><span class="ruby-operator">|</span> {
        <span class="ruby-value">:start_time</span> =<span class="ruby-operator">&gt;</span> <span class="ruby-identifier">r</span>[<span class="ruby-string">&quot;start_time&quot;</span>],
        <span class="ruby-value">:end_time</span> =<span class="ruby-operator">&gt;</span> <span class="ruby-identifier">r</span>[<span class="ruby-string">&quot;end_time&quot;</span>],
        <span class="ruby-value">:label</span> =<span class="ruby-operator">&gt;</span> <span class="ruby-identifier">r</span>[<span class="ruby-string">&quot;label&quot;</span>],
        <span class="ruby-value">:usage</span> =<span class="ruby-operator">&gt;</span> <span class="ruby-identifier">r</span>[<span class="ruby-string">&quot;usage&quot;</span>].<span class="ruby-identifier">to_f</span>,
        <span class="ruby-value">:confidence</span> =<span class="ruby-operator">&gt;</span> <span class="ruby-identifier">r</span>[<span class="ruby-string">&quot;confidence&quot;</span>].<span class="ruby-identifier">to_f</span>,
        <span class="ruby-value">:maximum_demand</span> =<span class="ruby-operator">&gt;</span> <span class="ruby-identifier">r</span>[<span class="ruby-string">&quot;maximum_demand&quot;</span>].<span class="ruby-identifier">to_f</span>,
        <span class="ruby-value">:uom</span> =<span class="ruby-operator">&gt;</span> <span class="ruby-identifier">r</span>[<span class="ruby-string">&quot;uom&quot;</span>]
      }
    <span class="ruby-keyword">end</span>

  <span class="ruby-keyword">end</span></pre>
          </div>
          
        </div>

        

        
      </div>

    
      <div id="method-c-total_meter_usage_sums" class="method-detail ">
        
        <div class="method-heading">
          <span class="method-name">total_meter_usage_sums</span><span
            class="method-args">(date_range, whitelist)</span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        

        <div class="method-description">
          
          <p>Gets an array of Meter&#39;s top-level total usage data hashes</p>

<p>Author: Reuben Braithwaite</p>

<h4 id="method-c-total_meter_usage_sums-label-Inputs">Inputs<span><a href="#method-c-total_meter_usage_sums-label-Inputs">&para;</a> <a href="#top">&uarr;</a></span></h4>
<ul><li>
<p><code>date_range</code> -  Date <code>start_date</code> and Date
<code>end_date</code></p>
</li><li>
<p><code>whitelist</code> - hash of meter_id =&gt; meter_serial tuples</p>
</li></ul>

<h3 id="method-c-total_meter_usage_sums-label-Outputs">Outputs<span><a href="#method-c-total_meter_usage_sums-label-Outputs">&para;</a> <a href="#top">&uarr;</a></span></h3>

<p>returns a array of hashes, containing meter-level total usage data</p>
          
          

          
          <div class="method-source-code" id="total_meter_usage_sums-source">
            <pre><span class="ruby-comment"># File app/models/meter_aggregation.rb, line 232</span>
<span class="ruby-keyword">def</span> <span class="ruby-keyword">self</span>.<span class="ruby-identifier">total_meter_usage_sums</span> <span class="ruby-identifier">date_range</span>, <span class="ruby-identifier">whitelist</span>
  <span class="ruby-identifier">dtps</span> = []
  <span class="ruby-identifier">dtps</span>.<span class="ruby-identifier">push</span> <span class="ruby-node">&quot;( start_time = &#39;#{all_day[:start_time]}&#39; AND end_time = &#39;#{all_day[:end_time]}&#39; )&quot;</span>

  <span class="ruby-identifier">sql</span> = <span class="ruby-node">&quot;SELECT
            serial,
            SUM(usage) AS usage,
            #{confidence_query} AS confidence,
            SUM(maximum_demand) as maximum_demand,
            TRIM(unit_of_measurement) as uom
          FROM
            meter_aggregations AS MA INNER JOIN meters AS M ON M.id = MA.meter_id
          WHERE
              meter_id = ANY(&#39;{#{whitelist.keys.join(&quot;,&quot;)}}&#39;::int[])
            AND
              ( date &gt;= &#39;#{date_range[:start_date]}&#39; AND date &lt;= &#39;#{date_range[:end_date]}&#39; )
            AND
              (
                #{dtps.join(&quot; OR &quot;)}
              )
          GROUP BY serial, uom
          ORDER BY serial;&quot;</span>
  <span class="ruby-comment">#logger.info sql</span>
  <span class="ruby-identifier">result</span> = <span class="ruby-constant">ActiveRecord</span><span class="ruby-operator">::</span><span class="ruby-constant">Base</span>.<span class="ruby-identifier">connection</span>.<span class="ruby-identifier">raw_connection</span>.<span class="ruby-identifier">exec</span> <span class="ruby-identifier">sql</span>
  <span class="ruby-identifier">result</span>.<span class="ruby-identifier">map</span> <span class="ruby-keyword">do</span>
    <span class="ruby-operator">|</span><span class="ruby-identifier">r</span><span class="ruby-operator">|</span> {
      <span class="ruby-value">:serial</span> =<span class="ruby-operator">&gt;</span> <span class="ruby-identifier">r</span>[<span class="ruby-string">&quot;serial&quot;</span>],
      <span class="ruby-value">:usage</span> =<span class="ruby-operator">&gt;</span> <span class="ruby-identifier">r</span>[<span class="ruby-string">&quot;usage&quot;</span>].<span class="ruby-identifier">to_f</span>,
      <span class="ruby-value">:confidence</span> =<span class="ruby-operator">&gt;</span> <span class="ruby-identifier">r</span>[<span class="ruby-string">&quot;confidence&quot;</span>].<span class="ruby-identifier">to_f</span>,
      <span class="ruby-value">:maximum_demand</span> =<span class="ruby-operator">&gt;</span> <span class="ruby-identifier">r</span>[<span class="ruby-string">&quot;maximum_demand&quot;</span>].<span class="ruby-identifier">to_f</span>,
      <span class="ruby-value">:uom</span> =<span class="ruby-operator">&gt;</span> <span class="ruby-identifier">r</span>[<span class="ruby-string">&quot;uom&quot;</span>]
    }
  <span class="ruby-keyword">end</span>
<span class="ruby-keyword">end</span></pre>
          </div>
          
        </div>

        

        
      </div>

    
      <div id="method-c-total_usage_sums" class="method-detail ">
        
        <div class="method-heading">
          <span class="method-name">total_usage_sums</span><span
            class="method-args">(date_range, whitelist)</span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        

        <div class="method-description">
          
          <p>Gets the total usage for all meters in the whitelist and for the date range
specified. Returns a float.</p>

<p>Author: Reuben Braithwaite</p>

<h4 id="method-c-total_usage_sums-label-Inputs">Inputs<span><a href="#method-c-total_usage_sums-label-Inputs">&para;</a> <a href="#top">&uarr;</a></span></h4>
<ul><li>
<p><code>date_range</code> -  Date <code>start_date</code> and Date
<code>end_date</code></p>
</li><li>
<p><code>whitelist</code> - hash of meter_id =&gt; meter_serial tuples</p>
</li></ul>

<h3 id="method-c-total_usage_sums-label-Outputs">Outputs<span><a href="#method-c-total_usage_sums-label-Outputs">&para;</a> <a href="#top">&uarr;</a></span></h3>

<p>returns a array of hashes, containing top-level total usage data</p>
          
          

          
          <div class="method-source-code" id="total_usage_sums-source">
            <pre><span class="ruby-comment"># File app/models/meter_aggregation.rb, line 478</span>
<span class="ruby-keyword">def</span> <span class="ruby-keyword">self</span>.<span class="ruby-identifier">total_usage_sums</span> <span class="ruby-identifier">date_range</span>, <span class="ruby-identifier">whitelist</span>
  <span class="ruby-identifier">dtps</span> = []
  <span class="ruby-identifier">dtps</span>.<span class="ruby-identifier">push</span> <span class="ruby-node">&quot;( start_time = &#39;#{all_day[:start_time]}&#39; AND end_time = &#39;#{all_day[:end_time]}&#39; )&quot;</span>

  <span class="ruby-identifier">sql</span> = <span class="ruby-node">&quot;SELECT
          SUM(usage) AS usage,
          #{confidence_query} AS confidence,
          SUM(maximum_demand) as maximum_demand,
          TRIM(unit_of_measurement) as uom
        FROM
          meter_aggregations
        WHERE
          meter_id = ANY(&#39;{#{whitelist.keys.join(&quot;,&quot;)}}&#39;::int[])
        AND
          ( date &gt;= &#39;#{date_range[:start_date]}&#39; AND date &lt;= &#39;#{date_range[:end_date]}&#39; )
        AND
          (
            #{dtps.join(&quot; OR &quot;)}
          )
        GROUP BY uom;&quot;</span>

  <span class="ruby-identifier">result</span> = <span class="ruby-constant">ActiveRecord</span><span class="ruby-operator">::</span><span class="ruby-constant">Base</span>.<span class="ruby-identifier">connection</span>.<span class="ruby-identifier">raw_connection</span>.<span class="ruby-identifier">exec</span> <span class="ruby-identifier">sql</span>

  <span class="ruby-keyword">if</span> ( <span class="ruby-identifier">result</span>.<span class="ruby-identifier">num_tuples</span>.<span class="ruby-identifier">zero?</span> ) <span class="ruby-keyword">then</span>
    <span class="ruby-keyword">return</span> {}
  <span class="ruby-keyword">end</span>

  <span class="ruby-keyword">return</span> {
    <span class="ruby-value">:usage</span> =<span class="ruby-operator">&gt;</span> <span class="ruby-identifier">result</span>[<span class="ruby-value">0</span>][<span class="ruby-string">&quot;usage&quot;</span>].<span class="ruby-identifier">to_f</span>,
    <span class="ruby-value">:confidence</span> =<span class="ruby-operator">&gt;</span> <span class="ruby-identifier">result</span>[<span class="ruby-value">0</span>][<span class="ruby-string">&quot;confidence&quot;</span>].<span class="ruby-identifier">to_f</span>,
    <span class="ruby-value">:maximum_demand</span> =<span class="ruby-operator">&gt;</span> <span class="ruby-identifier">result</span>[<span class="ruby-value">0</span>][<span class="ruby-string">&quot;maximum_demand&quot;</span>].<span class="ruby-identifier">to_f</span>,
    <span class="ruby-value">:uom</span> =<span class="ruby-operator">&gt;</span> <span class="ruby-identifier">result</span>[<span class="ruby-value">0</span>][<span class="ruby-string">&quot;uom&quot;</span>]
  }

<span class="ruby-keyword">end</span></pre>
          </div>
          
        </div>

        

        
      </div>

    
      <div id="method-c-usage_by_dtp" class="method-detail ">
        
        <div class="method-heading">
          <span class="method-name">usage_by_dtp</span><span
            class="method-args">(date_ranges, daily_time_periods, meters, detailed = false)</span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        

        <div class="method-description">
          
          <p>Gets usage data organised by daily time period.</p>

<p>Author: Reuben Braithwaite</p>

<h4 id="method-c-usage_by_dtp-label-Inputs">Inputs<span><a href="#method-c-usage_by_dtp-label-Inputs">&para;</a> <a href="#top">&uarr;</a></span></h4>
<ul><li>
<p><code>date_ranges</code> - an array of hashes, each containing a Date
<code>start_date</code> and Date <code>end_date</code> as specified in <a
href="Meter.html">Meter</a> interface of SDD</p>
</li><li>
<p><code>daily_time_periods</code> - an array of hashes, each containing a
Time <code>start_time</code>, Time <code>end_time</code> and, optionally, a
String <code>label</code>, as specified in <a href="Meter.html">Meter</a>
interface of SDD</p>
</li><li>
<p><code>meters</code> - an array of <a href="Meter.html">Meter</a> objects</p>
</li><li>
<p><code>detailed</code> - boolean, defaults to false</p>
</li></ul>

<h3 id="method-c-usage_by_dtp-label-Outputs">Outputs<span><a href="#method-c-usage_by_dtp-label-Outputs">&para;</a> <a href="#top">&uarr;</a></span></h3>

<p>returns an array of usage hashes, as specified in <a
href="Meter.html">Meter</a> interface of SDD</p>
          
          

          
          <div class="method-source-code" id="usage_by_dtp-source">
            <pre><span class="ruby-comment"># File app/models/meter_aggregation.rb, line 62</span>
  <span class="ruby-keyword">def</span> <span class="ruby-keyword">self</span>.<span class="ruby-identifier">usage_by_dtp</span> <span class="ruby-identifier">date_ranges</span>, <span class="ruby-identifier">daily_time_periods</span>, <span class="ruby-identifier">meters</span>, <span class="ruby-identifier">detailed</span> = <span class="ruby-keyword">false</span>
    <span class="ruby-identifier">whitelist</span> = <span class="ruby-constant">Meter</span>.<span class="ruby-identifier">whitelist</span> <span class="ruby-identifier">meters</span>
<span class="ruby-comment">#   Get an array of top level, inclusive usage data organised by date range</span>
    <span class="ruby-identifier">usages</span> = <span class="ruby-identifier">inclusive_usage</span> <span class="ruby-identifier">date_ranges</span>, <span class="ruby-identifier">meters</span>, <span class="ruby-identifier">detailed</span>

    <span class="ruby-identifier">options</span> = { <span class="ruby-value">:nest</span> =<span class="ruby-operator">&gt;</span> <span class="ruby-keyword">true</span>, <span class="ruby-value">:detailed</span> =<span class="ruby-operator">&gt;</span> <span class="ruby-identifier">detailed</span> }

    <span class="ruby-identifier">usages</span>.<span class="ruby-identifier">each</span> <span class="ruby-keyword">do</span> <span class="ruby-operator">|</span><span class="ruby-identifier">usage</span><span class="ruby-operator">|</span>
      <span class="ruby-identifier">usage</span>[<span class="ruby-value">:source</span>] = <span class="ruby-identifier">detailed</span> <span class="ruby-operator">?</span> <span class="ruby-string">&quot;Detailed Usage by Daily Time Period&quot;</span> <span class="ruby-operator">:</span> <span class="ruby-string">&quot;Usage by Daily Time Period&quot;</span>
      <span class="ruby-identifier">date_range</span> = {
        <span class="ruby-value">:start_date</span> =<span class="ruby-operator">&gt;</span> <span class="ruby-identifier">usage</span>[<span class="ruby-value">:start_date</span>],
        <span class="ruby-value">:end_date</span> =<span class="ruby-operator">&gt;</span> <span class="ruby-identifier">usage</span>[<span class="ruby-value">:end_date</span>]
      }
<span class="ruby-comment">#     Add an array of usage data hashes, broken down by Daily Time Period</span>
      <span class="ruby-identifier">usage</span>[<span class="ruby-value">:daily_time_periods</span>] = <span class="ruby-identifier">dtp_usage</span> <span class="ruby-identifier">date_range</span>, <span class="ruby-identifier">daily_time_periods</span>, <span class="ruby-identifier">whitelist</span>, <span class="ruby-identifier">options</span> <span class="ruby-keyword">unless</span> <span class="ruby-identifier">daily_time_periods</span>.<span class="ruby-identifier">empty?</span>
    <span class="ruby-keyword">end</span>
    <span class="ruby-keyword">return</span> <span class="ruby-identifier">usages</span>
  <span class="ruby-keyword">end</span></pre>
          </div>
          
        </div>

        

        
      </div>

    
      <div id="method-c-usage_by_meter" class="method-detail ">
        
        <div class="method-heading">
          <span class="method-name">usage_by_meter</span><span
            class="method-args">(date_ranges, daily_time_periods, meters, detailed = false)</span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        

        <div class="method-description">
          
          <p>Gets usage data organised by meter.</p>

<p>Author: Reuben Braithwaite</p>

<h4 id="method-c-usage_by_meter-label-Inputs">Inputs<span><a href="#method-c-usage_by_meter-label-Inputs">&para;</a> <a href="#top">&uarr;</a></span></h4>
<ul><li>
<p><code>date_ranges</code> - an array of hashes, each containing a Date
<code>start_date</code> and Date <code>end_date</code> as specified in <a
href="Meter.html">Meter</a> interface of SDD</p>
</li><li>
<p><code>daily_time_periods</code> - an array of hashes, each containing a
Time <code>start_time</code>, Time <code>end_time</code> and, optionally, a
String <code>label</code>, as specified in <a href="Meter.html">Meter</a>
interface of SDD</p>
</li><li>
<p><code>meters</code> - an array of <a href="Meter.html">Meter</a> objects</p>
</li><li>
<p><code>detailed</code> - boolean, defaults to false</p>
</li></ul>

<h3 id="method-c-usage_by_meter-label-Outputs">Outputs<span><a href="#method-c-usage_by_meter-label-Outputs">&para;</a> <a href="#top">&uarr;</a></span></h3>

<p>returns an array of usage hashes, as specified in <a
href="Meter.html">Meter</a> interface of SDD</p>
          
          

          
          <div class="method-source-code" id="usage_by_meter-source">
            <pre><span class="ruby-comment"># File app/models/meter_aggregation.rb, line 27</span>
  <span class="ruby-keyword">def</span> <span class="ruby-keyword">self</span>.<span class="ruby-identifier">usage_by_meter</span> <span class="ruby-identifier">date_ranges</span>, <span class="ruby-identifier">daily_time_periods</span>, <span class="ruby-identifier">meters</span>, <span class="ruby-identifier">detailed</span> = <span class="ruby-keyword">false</span>
    <span class="ruby-identifier">whitelist</span> = <span class="ruby-constant">Meter</span>.<span class="ruby-identifier">whitelist</span> <span class="ruby-identifier">meters</span>
<span class="ruby-comment">#   Get an array of top level, inclusive usage data organised by date range</span>
    <span class="ruby-identifier">usages</span> = <span class="ruby-identifier">inclusive_usage</span> <span class="ruby-identifier">date_ranges</span>, <span class="ruby-identifier">meters</span>, <span class="ruby-identifier">detailed</span>

    <span class="ruby-identifier">options</span> = { <span class="ruby-value">:nest</span> =<span class="ruby-operator">&gt;</span> <span class="ruby-keyword">true</span>, <span class="ruby-value">:detailed</span> =<span class="ruby-operator">&gt;</span> <span class="ruby-identifier">detailed</span> }

    <span class="ruby-identifier">usages</span>.<span class="ruby-identifier">each</span> <span class="ruby-keyword">do</span> <span class="ruby-operator">|</span><span class="ruby-identifier">usage</span><span class="ruby-operator">|</span>
      <span class="ruby-identifier">usage</span>[<span class="ruby-value">:source</span>] = <span class="ruby-identifier">detailed</span> <span class="ruby-operator">?</span> <span class="ruby-string">&quot;Detailed Usage by Meter&quot;</span> <span class="ruby-operator">:</span> <span class="ruby-string">&quot;Usage by Meter&quot;</span>
      <span class="ruby-identifier">date_range</span> = {
        <span class="ruby-value">:start_date</span> =<span class="ruby-operator">&gt;</span> <span class="ruby-identifier">usage</span>[<span class="ruby-value">:start_date</span>],
        <span class="ruby-value">:end_date</span> =<span class="ruby-operator">&gt;</span> <span class="ruby-identifier">usage</span>[<span class="ruby-value">:end_date</span>]
      }
<span class="ruby-comment">#     Add an array of usage data hashes, broken down by Meter</span>
      <span class="ruby-identifier">usage</span>[<span class="ruby-value">:meters</span>] = <span class="ruby-identifier">meter_usage</span> <span class="ruby-identifier">date_range</span>, <span class="ruby-identifier">daily_time_periods</span>, <span class="ruby-identifier">whitelist</span>, <span class="ruby-identifier">options</span>
    <span class="ruby-keyword">end</span>
    <span class="ruby-keyword">return</span> <span class="ruby-identifier">usages</span>
  <span class="ruby-keyword">end</span></pre>
          </div>
          
        </div>

        

        
      </div>

    
    </section>
  
  </section>
</main>


<footer id="validator-badges" role="contentinfo">
  <p><a href="http://validator.w3.org/check/referer">Validate</a>
  <p>Generated by <a href="http://docs.seattlerb.org/rdoc/">RDoc</a> 4.2.0.
  <p>Based on <a href="http://deveiate.org/projects/Darkfish-RDoc/">Darkfish</a> by <a href="http://deveiate.org">Michael Granger</a>.
</footer>

